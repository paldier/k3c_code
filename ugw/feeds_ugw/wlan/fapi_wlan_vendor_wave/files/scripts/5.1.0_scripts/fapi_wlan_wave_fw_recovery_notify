#!/bin/sh
# This script is used for the FW recovery commands from drvhlpr.
# It dumps FW memory and stop/start hostapd
# It is an API between drvhlpr and scripts

script_name="$0"

[ ! "$LIB_COMMON_SOURCED" ] && . /tmp/fapi_wlan_wave_lib_common.sh
[ ! "$LIB_RECOVERY_SOURCED" ] && . /tmp/fapi_wlan_wave_lib_recovery.sh

interface_name=$1
command=$2

# Find the interface index and the radio index
interface_index=`find_index_from_interface_name $interface_name`
radio_name=${interface_name%%.*}
radio_index=`find_index_from_interface_name $radio_name`

print2log $radio_index FW_RECOVERY "Running $script_name with: $*"

# Delete the runner file. It will be regenerated by the script.
rm -f ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

handle_fw_crash()
{
	# Define local parameters
	local interface_name tid wave_folder \
	dump_dir dump_files min_free_mem_kb memory_available \
	file fs_overlay overlay_mem_free tar_size i time_sec
	
	interface_name=$1

	# Source to get version information:
	# TODO: Add this file to Puma
	[ -e /etc/wave_components.ver ] && . /etc/wave_components.ver 

	# Source RADIO DB
	local_db_source RADIO

	# Read needed parameters from DB
	auto_recovery_dumps_enabled=`db2fapi_convert boolean WaveAutoRecoveryDumpsEnabled $interface_index`
	recovery_num_of_dumps=`db2fapi_convert boolean WaveRecoveryNumOfDumps $interface_index`

	tid=$$

	dump_files="shram
	um
	lm
	rx_handler_ram
	tx_sender_ram
	host_if_scpad
	host_if_ram
	rx_handler_scpad
	tx_sender_scpad"

	dump_dir=${wave_release_minor}_`date +%Y%m%dT%H%M%S`_${interface_name}_${tid}_dump

	cd $CONF_DIR
	
	# Minimum free memory required to save dumps
	min_free_mem_kb=`cat /proc/sys/vm/min_free_kbytes`
	min_free_mem_kb=$((min_free_mem_kb+2000))
	
	# Check if needed memory is available
	memory_available=`validate_memory $min_free_mem_kb`
	[ "$memory_available" = "1" ] && print2log $radio_index FW_RECOVERY "$script_name: No memory to save dump in $CONF_DIR - exit" && exit
	
	# Check if saving dumps is enabled
	[ "$auto_recovery_dumps_enabled" = "0" ] && print2log $radio_index FW_RECOVERY "$script_name: FW dumps saving is disabled - exit" && exit
	
	# If already have max dumps allowed, delete oldest to allow saving of newest
	prepare_folder_for_dumps $CONF_DIR $recovery_num_of_dumps
	
	# Zip each file and zip it all together
	mkdir $dump_dir
	for file in $dump_files
	do
		dump_file=/proc/net/mtlk/$interface_name/$file
		[ -e $dump_file ] && gzip -c $dump_file > $dump_dir/${file}.gz
	done
	tar cf ${dump_dir}.tar $dump_dir
	rm -rf $dump_dir
	
	# If persistent storage available: save a copy in non-volotile folder:

	# Support different persistent storage paths for UGW and Puma
	wave_folder=/opt/lantiq/wave
	[ -w /nvram/etc ] && wave_folder=/nvram/etc/wave_dumps && mkdir -p $wave_folder

	# Check write permissions
	if [ -w $wave_folder ]
	then
		# If already have max dumps allowed, delete oldest to allow saving of newest
		prepare_folder_for_dumps $wave_folder $recovery_num_of_dumps
		
		# Check min free memory in overlayfs before copying (and leave half spare)
		overlay_mem_free=`df | awk '/overlayfs:\/overlay/ {print $4}'`
		overlay_mem_free=$((overlay_mem_free*1024/2))
		tar_size=`ls -l ${dump_dir}.tar | awk '{print $5}'`
		if [ "$tar_size" -lt "$overlay_mem_free" ]
		then
			cp ${dump_dir}.tar $wave_folder/
		else
			# If there is not enough space to save the dump, delete another dump (if exists)
			i=$((recovery_num_of_dumps-1))
			while [ $i -gt 0 ]
			do
				prepare_folder_for_dumps $wave_folder $i
				overlay_mem_free=`df | awk '/overlayfs:\/overlay/ {print $4}'`
				overlay_mem_free=$((overlay_mem_free*1024/2))
				[ "$tar_size" -lt "$overlay_mem_free" ] && cp ${dump_dir}.tar $wave_folder/ && break
				i=$((i-1))
			done
			if [ "$i" = "0" ]
			then
				print2log $radio_index FW_RECOVERY "$script_name: Skipping copy of ${dump_dir}.tar to $wave_folder/ due to insufficient space."
				print2log $radio_index FW_RECOVERY "$script_name: Take ${dump_dir}.tar from $CONF_DIR"
			fi
		fi
	fi
	
	time_sec=`awk '{print $1}' < /proc/uptime`
	print2log $radio_index FW_RECOVERY "$script_name: tid=$tid; created: ${dump_dir}.tar ($time_sec)"
}

handle_fw_recovery_end()
{
	# Currently, nothing to do for fw_recovery_end
	
	# Define local parameters
	local interface_name
	
	interface_name=$1
	
	print2log $radio_index FW_RECOVERY "$script_name: currently, fw_recovery_end is not supported"
	exit 0
}

handle_hostapd_stop()
{
	# Define local parameters
	local interface_name radio_name
	
	interface_name=$1
	radio_name=${interface_name%%.*}

	# Delete the runner
	rm -f ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	(. $ETC_PATH/fapi_wlan_wave_down $radio_name "IN_FW_RECOVERY")

	# Execute the runner
	if [ -e "${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}" ]
	then
		chmod +x ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
		${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	fi
}

handle_hostapd_start()
{
	# Define local parameters
	local interface_name
	
	interface_name=$1

	(. $ETC_PATH/fapi_wlan_wave_up $interface_name "IN_FW_RECOVERY")
}

case "$command" in
	"fw_crash")
		handle_fw_crash $interface_name
		;;
	"fw_recovery_end")
		handle_fw_recovery_end $interface_name
		;;
	"hostapd_stop")
		handle_hostapd_stop $interface_name
		;;
	"hostapd_start")
		handle_hostapd_start $interface_name
		;;
	*)
		print2log $radio_index FW_RECOVERY "$script_name: unknown command $command"
		;;
esac

print2log $radio_index FW_RECOVERY "$script_name Done"
