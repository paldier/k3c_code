#!/bin/sh
# This script is used for the FW recovery commands from drvhlpr.
# It dumps FW memory and stop/start hostapd
# It is an API between drvhlpr and scripts

script_name="wave_wlan_fw_recovery_notify"

[ ! "$LIB_COMMON_SOURCED" ] && . /tmp/wave_wlan_lib_common.sh
[ ! "$LIB_RECOVERY_SOURCED" ] && . /tmp/wave_wlan_lib_recovery.sh
[ ! "$RC_CONF_SOURCED" ] && rc_conf_source

# Define local parameters
local interface_name
local command

interface_name=$1
command=$2

ap_index=`find_index_from_wave_if $interface_name`

print2log $ap_index FW_RECOVERY "Running $script_name with: $*"

# Delete the runner file. It will be regenerated by the script.
rm -f $CONF_DIR/$WAVE_WLAN_RUNNNER

handle_fw_crash()
{
	# Define local parameters
	local interface_name ap_index
	local tid mtlk_folder dump_dir dump_files min_free_mem_kb memory_available dump_ena dump_max file fs_overlay overlay_mem_free tar_size i time_sec
	
	interface_name=$1
	ap_index=$2

	# Source to get version information:
	. /etc/wave_components.ver
	tid=$$

	dump_files="shram
	um
	lm
	rx_handler_ram
	tx_sender_ram
	host_if_scpad
	host_if_ram
	rx_handler_scpad
	tx_sender_scpad"

	mtlk_folder=/root/mtlk
	dump_dir=${wave_release_minor}_`date +%Y%m%dT%H%M%S`_${interface_name}_${tid}_dump

	cd $TEMP_CONF_DIR
	
	# Minimum free memory required to save dumps
	min_free_mem_kb=`cat /proc/sys/vm/min_free_kbytes`
	min_free_mem_kb=$((min_free_mem_kb+2000))
	
	# Check if needed memory is available
	memory_available=`validate_memory $min_free_mem_kb`
	[ "$memory_available" = "1" ] && print2log $ap_index FW_RECOVERY "$script_name: No memory to save dump in /tmp - exit" && exit
	
	# Get number of max dumps to save
	eval dump_ena=\${wlphywave_${ap_index}_fwAutoRecoverDumpEna}
	if [ "$dump_ena" = "0" ]
	then
		print2log $ap_index FW_RECOVERY "$script_name: FW dumps saving is disabled - exit" && exit
	else
		eval dump_max=\${wlphywave_${ap_index}_fwAutoRecoverDumpLim}
	fi
	
	# If already have max dumps allowed, delete oldest to allow saving of newest
	prepare_folder_for_dumps $TEMP_CONF_DIR $dump_max
	
	# Zip each file and zip it all together
	mkdir $dump_dir
	for file in $dump_files
	do
		dump_file=/proc/net/mtlk/$interface_name/$file
		[ -e $dump_file ] && gzip -c $dump_file > $dump_dir/${file}.gz
	done
	tar cf ${dump_dir}.tar $dump_dir
	rm -rf $dump_dir
	
	# If overlay: save copy in non-volotile folder:
	fs_overlay=`mount | grep overlay`
	if [ -n "$fs_overlay" ]
	then
		# If already have max dumps allowed, delete oldest to allow saving of newest
		prepare_folder_for_dumps $mtlk_folder $dump_max
		
		# Check min free memory in overlayfs before copying (and leave half spare)
		overlay_mem_free=`df | awk '/overlayfs:\/overlay/ {print $4}'`
		overlay_mem_free=$((overlay_mem_free*1024/2))
		tar_size=`ls -l ${dump_dir}.tar | awk '{print $5}'`
		if [ "$tar_size" -lt "$overlay_mem_free" ]
		then
			cp ${dump_dir}.tar $mtlk_folder/
		else
			# If there is not enough space to save the dump, delete another dump (if exists)
			i=$((dump_max-1))
			while [ $i -gt 0 ]
			do
				prepare_folder_for_dumps $mtlk_folder $i
				overlay_mem_free=`df | awk '/overlayfs:\/overlay/ {print $4}'`
				overlay_mem_free=$((overlay_mem_free*1024/2))
				[ "$tar_size" -lt "$overlay_mem_free" ] && cp ${dump_dir}.tar $mtlk_folder/ && break
				i=$((i-1))
			done
			if [ "$i" = "0" ]
			then
				print2log $ap_index FW_RECOVERY "$script_name: Skipping copy of ${dump_dir}.tar to $mtlk_folder/ due to insufficient space."
				print2log $ap_index FW_RECOVERY "$script_name: Take ${dump_dir}.tar from $TEMP_CONF_DIR"
			fi
		fi
	fi
	
	time_sec=`awk '{print $1}' < /proc/uptime`
	print2log $ap_index FW_RECOVERY "$script_name: tid=$tid; created: ${dump_dir}.tar ($time_sec)"
}

handle_fw_recovery_end()
{
	# Currently, nothing to do for fw_recovery_end
	
	# Define local parameters
	local interface_name ap_index
	
	interface_name=$1
	ap_index=$2
	
	print2log $ap_index FW_RECOVERY "$script_name: currently, fw_recovery_end is not supported"
	exit 0
}

handle_hostapd_stop()
{
	# Define local parameters
	local interface_name ap_index
	
	interface_name=$1
	ap_index=$2

	(. $ETC_PATH/wave_wlan_down.sh $interface_name "IN_FW_RECOVERY")
}

handle_hostapd_start()
{
	# Define local parameters
	local interface_name ap_index
	
	interface_name=$1
	ap_index=$2

	(. $ETC_PATH/wave_wlan_up.sh $interface_name "IN_FW_RECOVERY")
}

case "$command" in
	"fw_crash")
		handle_fw_crash $interface_name $ap_index
		;;
	"fw_recovery_end")
		handle_fw_recovery_end $interface_name $ap_index
		;;
	"hostapd_stop")
		handle_hostapd_stop $interface_name $ap_index
		;;
	"hostapd_start")
		handle_hostapd_start $interface_name $ap_index
		;;
	*)
		print2log $ap_index FW_RECOVERY "$script_name: unknown command $command"
		;;
esac

# Execute the runner
if [ -e "$CONF_DIR/$WAVE_WLAN_RUNNNER" ]
then
	chmod +x $CONF_DIR/$WAVE_WLAN_RUNNNER
	$CONF_DIR/$WAVE_WLAN_RUNNNER
fi

print2log $ap_index FW_RECOVERY "$script_name Done"
